<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            01. 문자열의 양쪽 공백을 제거하는 customTrim() 함수 구현 -> 문자열의 공백 제거
            02. 대문자를 소문자로 변환하는 customToLowerCase() 함수 구현 -> 대소문자 변환
            03. 이를 활용하여 preprocessMessage() 구현 -> 문자열 전처리 제어
        */

        // 1. 문자열 앞뒤 무의미한 공백 제거 기능을 수행하는 함수
        function customTrim(str) {
            // str = "   Hello ChatGPT!   "
            // 양 끝에서 공백을 스캔할 두 포인터
            let start = 0; // 왼쪽(처음)
            let end = str.length - 1; // 오른쪽(끝)에서 시작하는 위치변수

            while (start <= end && str[start] === " ") { // " " -> 공백
                start++;
            }
            while (end >= start && str[end] === " ") {
                end--;
            }

            // start와 end는 선행 공백과 후행 공백문자를 제거한 실제적인 문자들을 가지는 위치가 되므로,
            // start와 end 사이 구간에 존재하는 문자를 하나씩 이어 붙여서 새 문자여을 만들어 리턴
            let result = "";

            for (let i = start; i <= end; i++) {
                result += str[i];
            }
            return result;
        } //customTrim(str)

        // 2. 문자열을 소문자로 바꾸는 함수(A-Z -> a-z)
        function customToLowerCase(str) {
            let result = "";

            for (let i = 0; i < str.length; i++) {
                const code = str.charCodeAt(i); //해당 문자의 유니코드 값(정수)을 반환
                // A=65, a=97
                // 삼항 연산자 : (조건) ? True 값 : False 값;
                result += (code >= 65 && code <= 90) ? String.fromCharCode(code + 32) : str[i]; //대문자면 소문자로 바꿔 추가하고, 아니면 그대로 추가함
            }

            return result;
        }
        // 사용예시
        console.log(customToLowerCase("HELLO World!")); //hello world!

        // 3. 이러한 문자열 전처리 함수들의 전체 제어(사용자 메시지를 정제하는 메인 함수)
        function preprocessMessage(message) {
            const trimmed = customTrim(message); //공백제거
            const lowered = customToLowerCase(trimmed); //문자열을 소문자로 변경
            return lowered; // 최종 결과를 전처리된 문자열 출력
        }
        // 테스트
        console.log(preprocessMessage("  Hello ChatGPT!  ")); // hello chatgpt! 
        console.log(preprocessMessage("OPENAI")); //openai 

        var test = preprocessMessage("   Hello ChatGPT!   ");
        console.log(test); //hello chatgpt! 
    </script>

    <script>
        console.log("====================================================================================");
    </script>

    <script>
        // 입력 메시지에 따른 조건 분기 응답 생성하는 함수입니다.(차후 LLM API 응답 처리로 대체 가능)
        function getResponse(message) {
            const cleaned = preprocessMessage(message);

            // 입력 메시지에 대한 응답내용 처리 로직
            if (cleaned.includes("hello")) {
                return "Hi there! How can i help you?";
            } else if (cleaned.includes("bye")) {
                return "Goodbye!";
            } else {
                return "I'm not sure what you mean.";
            }
        }
        // 테스트
        console.log(getResponse(" Hello there! ")); //Hi there! How can i help you?
        console.log(getResponse("bye now")); //Goodbye!
        console.log(getResponse("what is this?")); //I'm not sure what you mean.

        // 함수를 구성 요소 단위로 나누고 연결해 작은 챗봇 흐름 구성
        // 이후에는 LLM 호출, 대화 히스토리 등으로 확장 가능
        function simulateChat(userInput) {
            const cleanedMessage = preprocessMessage(userInput);
            // 정제된 메시지를 기반으로 getResponse 함수가 실행
            const response = getResponse(cleanedMessage);
            return `[User]${userInput}\n[Bot]${response}`;
        }
        //테스트
        console.log(simulateChat("Hello, bot!"));
        //[User]Hello, bot!
        //[Bot]Hi there! How can i help you?
        console.log(simulateChat("Can you help me?"));
        //[User]Can you help me?
        //[Bot]I'm not sure what you mean.
        console.log(simulateChat("bye"));
        //[User]bye
        //[Bot]Goodbye!
    </script>
</body>
</html>