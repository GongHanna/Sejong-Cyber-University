<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            자바스크립트의 객체지향적 특징
            -  자바스크립트는 함수형 + 객체지향 혼합 지원
                -> 멀티 패러다임 언어
            - 전통적인 클래스 기반 X -> 프로토타입 기반 OOP
            - ES6 이후부터는 Class 문법 제공으로 더 친숙하게 사용 가능


            객체 정의 방식
            - 객체 리터럴 {}를 사용한 선언 방법
            - 생성자 함수 패턴 활용(ES5) 선언 방법
            - 클래스(ES6) 선언 방법
        */

        // 객체 리터럴 {}를 사용한 방식
        // - 단 하나의 객체만 만들 때 적합
        // - 동일한 구조의 여러개의 객체를 만들기엔 비효울적(복제 어려움)
        const player1 = {
            x:0, // 키: 값
            y:0,
            display:function(){
                console.log(this.x + "," + this.y + ": Player");
            },
            moveLeft:function() {
                this.x -= 1;
            },
            moveRight:function() {
                this.x += 1;
            }
        };
        // 사용
        player1.moveRight();
        player1.display(); //1,0: Player


        // 생성자 함수 패턴 활용(ES5) 선언 방법
        // - 여러 인스턴스 생성 가능(new 키워드 사용)
        // - 메소드는 프로토아입에 정의하여 메모리 절약 -> 클래스의 상속 개념을 프로토타입 기반으로 흉내낸 구조
        // - 실제로는 클래스가 아닌 객체의 원형(Prototype)을 참조한느 구조이지만, 사용자는 마치 클래스처럼 인스턴스를 만들고 공통 기능을 재사용 가능 -> 프로토타입 기반
        // - 동적인 속성 및 메소드 추가 기능
        function Player2(x, y) { // 생성자 함수
            this.x = x;
            this.y = y;
        }

        Player2.prototype.display = function() {
            console.log(this.x + "," + this.y + ": Player");
        };

        Player2.prototype.moveLeft = function() {
            this.x -= 1;
        };

        Player2.prototype.moveRight = function() {
            this.x += 1;
        };

        // 사용
        const player2 = new Player2(0, 0); // 인스턴스 생성
        player2.moveLeft();
        player2.display(); // -1,0: Player

        const player3 = new Player2(10, 20);
        player3.moveLeft();
        player3.display(); // 9,20: Player



        // 클래스(ES6) 선언 방식
        // - 문법이 Java와 유사하여 가독성이 높음
        // - 내부적으로는 여전히 프로토타입 기반임
        // - 생성자 함수보다 선언이 간결하고 직관적임
        class Player3 {
            constructor(x,y) {
                this.x = x;
                this.y = y;
            }

            display() {
                console.log(this.x + "," + this.y + ": Player");
            }

            moveLeft() {
                this.x -= 1;
            }

            moveRight() {
                this.x += 1;
            }
        } //class

        // 사용
        const player4 = new Player3(0,0);
        player4.moveRight();
        player4.display(); //1,0: Player

        /*
            상속 기반 vs 프로토타입 기반
            - Class 방식의 상속(JAVA의 경우)
                - 자바스크립트의 Class 선언 방식은 프로토타입 기반의 실행을 원칙으로 표현 방식만 Class(ES6)를 사용하는 것!!
            - 프로토타입 체인
                - 자바스크립트의 모든 객체
                    - 자신의 부모 역할을 담당하는 객체와 연결되어 잇음
                    - 객체지향의 상속 개념과 같이 부모객체의 프로퍼티 또는 메소드를 공유받아 사용할 수 있게 함
                        (부모객체 : 프로토타입 객체 또는 줄여서 프로토타입이라고 함)
                - 프로토타입 객체는 생성자 함수에 의해 생성된 모든 객체가 함께 쓸 수 있는 속성과 기능을 담아두는 공간
                - 프로토타입 체인 형성
                    - 프로퍼티/메서드 탐색 -> 없으면 [[Prototype]] 따라 상위 프로토타입 -> 최상위 Object.prototype까지 검색
                - [[Prototype]] 인터널 슬록
                    - 자신의 프로토타입(부모 역할) 객체를 가리키는 슬록
                - 프로토타입 객체는 constructor 프로퍼리티를 가짐
                    - constructor 프로퍼티 : 객체의 입장에서 자신을 생성한 객체
        */

        //객체의 속성 접근과 동적 속성 접근
        const user = {name: "Hanna", age: 28};

        // 1. 점 표기법
        console.log(user.name); //Hanna

        // 2. 대괄호 표기범
        console.log(user["age"]); //28

        function printUserInfo(iser, propName) {
            console.log(user[propName]);
            // 대괄호 표기법: propName이 변수이기 때문
        }

        printUserInfo(user, "name");
        printUserInfo(user, "age");
        // - 점 표기법은 정적 접근(속성 이름이 고정일 때)
        // - 대괄호 표기법은 동적 접근(변수로 속성이름을 넣을 때) 유용

        /*
            배열이란?
            - 여러개의 데이터를 묶어 하나의 이름(주소)으로 관리하는 자료관리 기술
            - 하나의 이름으로 여러 공간을 한꺼번에 다룸
        */

        // 배열 객체 - 생성과 구조
        const fruits = ["apple", "banana", "cherry"]; //배열 생성(권장)

        // 배열참조
        //  - 배열은 사실상 객체이지만 length와 index 기반으로 작동
        Array.isArray(fruits); //true
        typeof fruits; //'object'

        /*
            자주 사용하는 배열 매소드
            - push() : 배열 끝에 요소 추가
                arr.push("grape")
            - map() : 요소 변형(새 배열 반환)
                arr.map(x => x*2)
            - filter() : 조건에 맞는 요소만 추출
                arr.filter(x >= x > 5)
            - forEach() : 배열의 각 요소를 하나씩 꺼내서, 지정한 콜백 함수를 실행
                arr.forEach(x => console.log(x))
            - reduce() : 누적 계산
                arr.reduce((a,b) => a + b, 0)
        */

        // 반복문과 배열의 연계
        // - for, for...of, forEach() 함께 배열을 사용하면 기능이 강력해짐
        // - 사용자 목록 배열 출력
        // - 점수 배열을 순회하여 합계 및 평균 계산
        const arr = [1,2,3,4];
        // 기본 for문 - 탐색 시 index를 활용
        for (let i = 0; i < arr.length; i++) {
            console.log(arr[i]);
        }
        // for...of - 값을 직접 순회, 간결 문법
        for (let item of arr) {
            console.log(item);
        }
        // forEach - 배열 전용 메소드, 콜백 사용
        arr.forEach(item => console.log(item));

        /*
            배열 vs 객체 차이점
            1. 배열 : 순서가 중요할 때 사용 (리스트, 컬렉션)
            2. 객체 : 의미 있느 속성(key)을 저장할 때 사용 (사용자 정보, 설정 값 등)

            구분            배열(Array)                         객체(Object)
            접근방식        숫자인덱스 기반                     문자형 키(key)기반
            용도            순서가 있는 데이터 집합에 적합      속성(이름:값) 형태의 정보에 적합
            예시            const arr = [10,20,30];             const obj = {name: "Hanna", age: 28}
            접근명령        arr[0] -> 10                        obj.name 또는 obj["name"] -> Hanna
            반복            for, forEach, map, filter 등        for...in, Object.keys() 등 사용
        */


        // 객체 배열
        const users = [ //배열의 요소가 객체들로 나열됨 = 객체배열
            {name: "Alice", age: 25},
            {name: "Bob", age: 30}
        ];

        // 모든 이름 출력
        users.forEach(user => { //각 user 객체에 대해 콜백 실행
            console.log(user.name);
        });
        // 결과 : Alice, Bob


        // 다차원 배열
        // - 배열의 요소로 또 다른 배열을 포함하는 배열
        const matrix = [ //2차원 배열
            [1,2,3],
            [4,5,6]
        ];

        console.log(matrix[0][1]); //2, [행][열]
    </script>
</body>
</html>